dialect = https://cdn.jsdelivr.net/gh/angelonuffer/dialect@d37c62e/code/0

// --- Independent Rules (No whitespace dependency) ---

// Comment syntax support (using negation grammar type)
newline_chars = {
  type: "alternative"
  options: [
    { type: "symbol" text: "
" }
    { type: "symbol" text: "\r" }
  ]
}

single_line_comment_char = {
  type: "negation"
  grammar: newline_chars
}

single_line_comment_content = {
  type: "repetition"
  grammar: single_line_comment_char
  format: "text"
  minimum: 0
}

single_line_comment = {
  type: "sequence"
  parts: [
    { type: "symbol" text: "/" }
    { type: "symbol" text: "/" }
    single_line_comment_content
  ]
  format: "text"
}

asterisk_symbol = { type: "symbol" text: "*" }
slash_symbol = { type: "symbol" text: "/" }

not_asterisk = {
  type: "negation"
  grammar: asterisk_symbol
}

not_slash = {
  type: "negation"
  grammar: slash_symbol
}

asterisk_not_slash = {
  type: "sequence"
  parts: [
    asterisk_symbol
    not_slash
  ]
  format: "text"
}

multi_line_comment_content_char = {
  type: "alternative"
  options: [
    not_asterisk
    asterisk_not_slash
  ]
}

multi_line_comment_content = {
  type: "repetition"
  grammar: multi_line_comment_content_char
  format: "text"
  minimum: 0
}

multi_line_comment = {
  type: "sequence"
  parts: [
    slash_symbol
    asterisk_symbol
    multi_line_comment_content
    asterisk_symbol
    slash_symbol
  ]
  format: "text"
}

comment = {
  type: "alternative"
  options: [
    single_line_comment
    multi_line_comment
  ]
}

// Basic identifier parts (shared)
identifier_start = {
  type: "alternative"
  options: [
    { type: "range" from: "a" to: "z" }
    { type: "range" from: "A" to: "Z" }
    { type: "symbol" text: "_" }
  ]
}

identifier_char = {
  type: "alternative"
  options: [
    { type: "range" from: "a" to: "z" }
    { type: "range" from: "A" to: "Z" }
    { type: "range" from: "0" to: "9" }
    { type: "symbol" text: "_" }
  ]
}

// Primitive content rules (no whitespace)
string_content_char = {
  type: "alternative"
  options: [
    { type: "symbol" text: "\\'" }
    { type: "symbol" text: "\\\\" }
    { type: "range" from: " " to: "&" }
    { type: "range" from: "(" to: "[" }
    { type: "range" from: "]" to: "~" }
  ]
}

char_class_item = {
  type: "alternative"
  options: [
    {
      type: "sequence"
      parts: [
        {
          type: "alternative"
          options: [
            { type: "range" from: " " to: "\\" }
            { type: "range" from: "^" to: "~" }
          ]
        }
        { type: "symbol" text: "-" }
        {
          type: "alternative"
          options: [
            { type: "range" from: " " to: "\\" }
            { type: "range" from: "^" to: "~" }
          ]
        }
      ]
      format: "text"
    }
    {
      type: "alternative"
      options: [
        { type: "range" from: " " to: "\\" }
        { type: "range" from: "^" to: "~" }
      ]
    }
  ]
}

// --- Whitespace-Dependent Rules Factory ---

make_antlr_grammar = { ws_char } => (
  ws = {
    type: "repetition"
    grammar: ws_char
    format: "text"
    minimum: 1
  }

  opt_ws = {
    type: "repetition"
    grammar: ws_char
    format: "text"
    minimum: 0
  }

  // Identifiers (defined here to ensure any future whitespace dependency is handled)
  identifier = {
    type: "sequence"
    parts: [
      identifier_start
      {
        type: "repetition"
        grammar: identifier_char
        format: "text"
        minimum: 0
      }
    ]
    format: "text"
  }

  parser_rule_name = {
    type: "sequence"
    parts: [
      { type: "range" from: "a" to: "z" }
      {
        type: "repetition"
        grammar: identifier_char
        format: "text"
        minimum: 0
      }
    ]
    format: "text"
  }

  lexer_rule_name = {
    type: "sequence"
    parts: [
      { type: "range" from: "A" to: "Z" }
      {
        type: "repetition"
        grammar: identifier_char
        format: "text"
        minimum: 0
      }
    ]
    format: "text"
  }

  string_literal = {
    type: "sequence"
    parts: [
      { name: "open" grammar: { type: "symbol" text: "'" } }
      { name: "content" grammar: {
        type: "repetition"
        grammar: string_content_char
        format: "text"
        minimum: 0
      }}
      { name: "close" grammar: { type: "symbol" text: "'" } }
    ]
    format: "object"
  }

  char_class = {
    type: "sequence"
    parts: [
      { name: "open" grammar: { type: "symbol" text: "[" } }
      { name: "content" grammar: {
        type: "repetition"
        grammar: char_class_item
        format: "text"
        minimum: 1
      }}
      { name: "close" grammar: { type: "symbol" text: "]" } }
    ]
    format: "object"
  }

  rule_element = {
    type: "alternative"
    options: [
      string_literal
      char_class
      identifier
    ]
  }

  // Rule body - sequence of elements
  rule_body = {
    type: "sequence"
    parts: [
      { name: "first" grammar: rule_element }
      { name: "rest" grammar: {
        type: "repetition"
        grammar: {
          type: "sequence"
          parts: [
            { name: "ws" grammar: ws }
            { name: "element" grammar: rule_element }
          ]
          format: "object"
        }
        format: "list"
        minimum: 0
      }}
    ]
    format: "object"
  }

  // Parser rule definition
  parser_rule = {
    type: "sequence"
    parts: [
      { name: "name" grammar: parser_rule_name }
      { name: "ws1" grammar: opt_ws }
      { name: "colon" grammar: { type: "symbol" text: ":" } }
      { name: "ws2" grammar: opt_ws }
      { name: "body" grammar: rule_body }
      { name: "ws3" grammar: opt_ws }
      { name: "semicolon" grammar: { type: "symbol" text: ";" } }
    ]
    format: "object"
  }

  // Lexer rule definition
  lexer_rule = {
    type: "sequence"
    parts: [
      { name: "name" grammar: lexer_rule_name }
      { name: "ws1" grammar: opt_ws }
      { name: "colon" grammar: { type: "symbol" text: ":" } }
      { name: "ws2" grammar: opt_ws }
      { name: "body" grammar: rule_body }
      { name: "ws3" grammar: opt_ws }
      { name: "semicolon" grammar: { type: "symbol" text: ";" } }
    ]
    format: "object"
  }

  // Any rule (parser or lexer) - try lexer first
  any_rule = {
    type: "alternative"
    options: [
      lexer_rule
      parser_rule
    ]
  }

  // Grammar declaration
  grammar_decl = {
    type: "sequence"
    parts: [
      { name: "keyword" grammar: { type: "symbol" text: "grammar" } }
      { name: "ws1" grammar: ws }
      { name: "name" grammar: identifier }
      { name: "ws2" grammar: opt_ws }
      { name: "semicolon" grammar: { type: "symbol" text: ";" } }
    ]
    format: "object"
  }

  // Full grammar with optional rules
  antlr_grammar = {
    type: "sequence"
    parts: [
      { name: "ws_start" grammar: opt_ws }
      { name: "grammar_decl" grammar: grammar_decl }
      { name: "rules" grammar: {
        type: "repetition"
        grammar: {
          type: "sequence"
          parts: [
            { name: "ws" grammar: opt_ws }
            { name: "rule" grammar: any_rule }
          ]
          format: "object"
        }
        format: "list"
        minimum: 0
      }}
      { name: "ws_end" grammar: opt_ws }
    ]
    format: "object"
  }

  antlr_grammar
)

// --- Grammar Instances ---

ws_char_base = {
  type: "alternative"
  options: [
    { type: "symbol" text: " " }
    { type: "symbol" text: "\t" }
    { type: "symbol" text: "
" }
    { type: "symbol" text: "\r" }
  ]
}

ws_char_parse = {
  type: "alternative"
  options: [
    { type: "symbol" text: " " }
    { type: "symbol" text: "\t" }
    { type: "symbol" text: "
" }
    { type: "symbol" text: "\r" }
    comment
  ]
}

ws_char_generate = ws_char_base

antlr_grammar_parse = make_antlr_grammar({ ws_char: ws_char_parse })
antlr_grammar_generate = make_antlr_grammar({ ws_char: ws_char_generate })

// --- API ---

// Parse function
parse = { input } => dialect.parse({
  input: input
  grammar: antlr_grammar_parse
})

// Generate function
generate = { ast } => dialect.generate({
  value: ast
  grammar: antlr_grammar_generate
})

// Export API
{
  parse: parse
  generate: generate
  grammar: antlr_grammar_parse
}
